/**
 * HYBRID_VULNERABILITY_CHECKER.ts
 * Hybrid approach: Local DB → External API (with fallback)
 * Works in both online and offline modes
 */

import { VULNERABLE_LIBS_DB, checkVulnerability } from './vulnerability-db.js';

// ===========================
// 1. INTERNET ACCESS DETECTION
// ===========================

/**
 * Check if external APIs are accessible
 * Returns true if at least one external API is reachable
 */
export async function hasInternetAccess(): Promise<boolean> {
  const timeoutMs = 3000; // 3 second timeout

  try {
    // Try to fetch OSV API
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

    const response = await fetch('https://api.osv.dev/v1/', {
      method: 'HEAD',
      signal: controller.signal,
    });

    clearTimeout(timeoutId);
    return response.ok || response.status < 500;
  } catch (error) {
    return false;
  }
}

// ===========================
// 2. OSV API INTEGRATION
// ===========================

interface OSVVulnerability {
  id: string;
  summary: string;
  details: string;
  affected: Array<{
    package: {
      name: string;
      ecosystem: string;
    };
    ranges: Array<{
      version: string;
      type: string;
      events: Array<{
        introduced?: string;
        fixed?: string;
      }>;
    }>;
  }>;
}

interface OSVResponse {
  vulns: OSVVulnerability[];
}

/**
 * Fetch vulnerability information from OSV API
 * Works with GitHub, npm, PyPI, Maven, etc.
 */
async function fetchOSVVulnerability(
  libName: string,
  version: string,
  ecosystem: string = 'npm'
): Promise<OSVVulnerability[] | null> {
  try {
    const response = await fetch(
      `https://api.osv.dev/v1/query?package.name=${encodeURIComponent(libName)}&package.ecosystem=${encodeURIComponent(ecosystem)}&version=${encodeURIComponent(version)}`,
      {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
        signal: AbortSignal.timeout(5000), // 5 second timeout
      }
    );

    if (!response.ok) {
      return null;
    }

    const data: OSVResponse = await response.json();
    return data.vulns || [];
  } catch (error) {
    // Network error, timeout, or API unavailable
    return null;
  }
}

// ===========================
// 3. HYBRID VULNERABILITY CHECKER
// ===========================

export interface VulnerabilityCheckResult {
  library: string;
  version: string;
  isVulnerable: boolean;
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO';
  cve?: string;
  type: string;
  source: 'LOCAL_DB' | 'EXTERNAL_API' | 'OFFLINE_MODE';
  externalAPIAvailable: boolean;
  recommendation?: string;
  description?: string;
}

/**
 * Check library vulnerability using hybrid approach
 * Priority: Local DB → External API → Offline mode
 */
export async function checkLibraryVulnerabilityHybrid(
  libName: string,
  version: string,
  ecosystem: string = 'npm'
): Promise<VulnerabilityCheckResult> {
  const normalizedLibName = libName.toLowerCase().trim();

  // STEP 1: Check in local database
  const localVuln = checkVulnerability(normalizedLibName, version);
  if (localVuln) {
    return {
      library: libName,
      version,
      isVulnerable: true,
      severity: localVuln.severity as any,
      cve: localVuln.cve,
      type: localVuln.type,
      source: 'LOCAL_DB',
      externalAPIAvailable: false, // Not needed, found in local DB
      recommendation: `Upgrade ${libName} to a version newer than ${version}`,
      description: `Local DB: ${localVuln.cve} - ${localVuln.type}`,
    };
  }

  // STEP 2: Check external API (if available)
  const internetAvailable = await hasInternetAccess();

  if (internetAvailable) {
    const externalVulns = await fetchOSVVulnerability(
      normalizedLibName,
      version,
      ecosystem
    );

    if (externalVulns && externalVulns.length > 0) {
      // Get the most severe vulnerability
      const severityOrder = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO'];
      let mostSevere = externalVulns[0];

      for (const vuln of externalVulns) {
        const vulnSeverity = extractOSVSeverity(vuln);
        const currentSeverity = extractOSVSeverity(mostSevere);

        if (
          severityOrder.indexOf(vulnSeverity) <
          severityOrder.indexOf(currentSeverity)
        ) {
          mostSevere = vuln;
        }
      }

      return {
        library: libName,
        version,
        isVulnerable: true,
        severity: extractOSVSeverity(mostSevere),
        cve: mostSevere.id,
        type: mostSevere.details || 'Multiple CVEs',
        source: 'EXTERNAL_API',
        externalAPIAvailable: true,
        recommendation: `Upgrade ${libName} to fix: ${mostSevere.id}`,
        description: `OSV API: ${mostSevere.id} - ${mostSevere.summary}`,
      };
    }

    // No vulnerabilities found in external API
    return {
      library: libName,
      version,
      isVulnerable: false,
      severity: 'INFO',
      type: 'No Vulnerabilities',
      source: 'EXTERNAL_API',
      externalAPIAvailable: true,
      description: 'No known vulnerabilities found (OSV API)',
    };
  }

  // STEP 3: Offline mode - no internet access
  return {
    library: libName,
    version,
    isVulnerable: false,
    severity: 'INFO',
    type: 'Limited Check',
    source: 'OFFLINE_MODE',
    externalAPIAvailable: false,
    description: 'Offline mode - only local database checked',
    recommendation: 'Connect to internet for full vulnerability scan',
  };
}

/**
 * Extract severity from OSV vulnerability
 */
function extractOSVSeverity(vuln: OSVVulnerability): 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' {
  // OSV doesn't always provide severity, so we estimate
  const summary = vuln.summary.toLowerCase();
  const details = vuln.details.toLowerCase();

  if (summary.includes('critical') || details.includes('critical') ||
      summary.includes('rce') || summary.includes('code execution')) {
    return 'CRITICAL';
  }

  if (summary.includes('high') || details.includes('high') ||
      summary.includes('xss') || summary.includes('injection')) {
    return 'HIGH';
  }

  if (summary.includes('medium') || details.includes('medium') ||
      summary.includes('dos') || summary.includes('memory')) {
    return 'MEDIUM';
  }

  return 'LOW';
}

// ===========================
// 4. BATCH CHECKING
// ===========================

export interface LibraryToCheck {
  name: string;
  version: string;
  ecosystem?: string;
}

/**
 * Check multiple libraries for vulnerabilities
 * Returns results with status indicator
 */
export async function checkMultipleLibraries(
  libraries: LibraryToCheck[]
): Promise<{
  results: VulnerabilityCheckResult[];
  internetAvailable: boolean;
  checkedWithLocalDB: number;
  checkedWithExternalAPI: number;
  checkedInOfflineMode: number;
}> {
  const internetAvailable = await hasInternetAccess();
  const results: VulnerabilityCheckResult[] = [];
  let checkedWithLocalDB = 0;
  let checkedWithExternalAPI = 0;
  let checkedInOfflineMode = 0;

  // Process libraries in batches to avoid overwhelming external API
  const batchSize = 5;
  for (let i = 0; i < libraries.length; i += batchSize) {
    const batch = libraries.slice(i, i + batchSize);
    const batchResults = await Promise.all(
      batch.map(lib =>
        checkLibraryVulnerabilityHybrid(lib.name, lib.version, lib.ecosystem)
      )
    );

    results.push(...batchResults);

    // Update statistics
    batchResults.forEach(result => {
      if (result.source === 'LOCAL_DB') {
        checkedWithLocalDB++;
      } else if (result.source === 'EXTERNAL_API') {
        checkedWithExternalAPI++;
      } else {
        checkedInOfflineMode++;
      }
    });

    // Small delay between batches
    if (i + batchSize < libraries.length) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }

  return {
    results,
    internetAvailable,
    checkedWithLocalDB,
    checkedWithExternalAPI,
    checkedInOfflineMode,
  };
}

// ===========================
// 5. Ecosystem Detection
// ===========================

/**
 * Detect ecosystem from library name/pattern
 */
export function detectEcosystem(libName: string): string {
  const name = libName.toLowerCase();

  // npm/Node.js patterns
  if (name.startsWith('@') ||
      name.includes('react') ||
      name.includes('angular') ||
      name.includes('vue') ||
      name.includes('jquery') ||
      name.includes('express') ||
      name.includes('lodash') ||
      name.includes('webpack') ||
      name.includes('babel')) {
    return 'npm';
  }

  // Python patterns
  if (name.includes('python') ||
      name.includes('django') ||
      name.includes('flask') ||
      name.includes('pandas') ||
      name.includes('numpy') ||
      name.includes('requests')) {
    return 'PyPI';
  }

  // Java/Maven patterns
  if (name.includes('spring') ||
      name.includes('hibernate') ||
      name.includes('log4j')) {
    return 'Maven';
  }

  // RubyGems patterns
  if (name.includes('rails') ||
      name.includes('activerecord')) {
    return 'RubyGems';
  }

  // Default to npm (most common for frontend)
  return 'npm';
}

// ===========================
// 6. UTILITY FUNCTIONS
// ===========================

/**
 * Check if we should use external API
 * Based on library popularity and frequency
 */
export function shouldUseExternalAPI(libName: string, frequency: number = 1): boolean {
  // Always try external API for popular libraries
  const popularLibraries = [
    'react', 'vue', 'angular', 'jquery', 'lodash', 'moment',
    'express', 'axios', 'bootstrap', 'material-ui', 'ant-design'
  ];

  if (popularLibraries.includes(libName.toLowerCase())) {
    return true;
  }

  // For frequently scanned libraries, use external API
  if (frequency > 5) {
    return true;
  }

  return false;
}

/**
 * Generate summary report from vulnerability check results
 */
export function generateVulnerabilitySummary(
  results: VulnerabilityCheckResult[]
): {
  total: number;
  vulnerable: number;
  critical: number;
  high: number;
  medium: number;
  low: number;
  bySource: {
    localDB: number;
    externalAPI: number;
    offlineMode: number;
  };
} {
  const summary = {
    total: results.length,
    vulnerable: 0,
    critical: 0,
    high: 0,
    medium: 0,
    low: 0,
    bySource: {
      localDB: 0,
      externalAPI: 0,
      offlineMode: 0,
    },
  };

  results.forEach(result => {
    if (result.isVulnerable) {
      summary.vulnerable++;
      if (result.severity === 'CRITICAL') summary.critical++;
      else if (result.severity === 'HIGH') summary.high++;
      else if (result.severity === 'MEDIUM') summary.medium++;
      else if (result.severity === 'LOW') summary.low++;
    }

    if (result.source === 'LOCAL_DB') summary.bySource.localDB++;
    else if (result.source === 'EXTERNAL_API') summary.bySource.externalAPI++;
    else if (result.source === 'OFFLINE_MODE') summary.bySource.offlineMode++;
  });

  return summary;
}

import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

function generateCSV(vulnerabilities: any[]) {
  const headers = ['Type', 'Severity', 'Title', 'Description', 'Recommendation', 'OWASP Category']
  const rows = vulnerabilities.map(v => [
    v.type,
    v.severity,
    `"${(v.title || '').replace(/"/g, '""')}"`,
    `"${(v.description || '').replace(/"/g, '""')}"`,
    `"${(v.recommendation || v.recommendation || '').replace(/"/g, '""')}"`,
    v.owaspCategory || '',
  ])

  return [
    headers.join('\t'),
    ...rows.map(row => row.join('\t'))
  ].join('\n')
}

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams
  const scanId = searchParams.get('scanId')
  const format = searchParams.get('format') || 'json'

  console.log('=== API EXPORT REQUEST ===')
  console.log('Export request received for scanId:', scanId, 'format:', format)
  console.log('Database URL configured:', !!process.env.DATABASE_URL)
  console.log('Database URL preview:', process.env.DATABASE_URL?.substring(0, 30) + '...')

  if (!scanId) {
    console.log('âŒ scanId parameter is missing')
    return NextResponse.json(
      { error: 'scanId parameter is required' },
      { status: 400 }
    )
  }

  try {
    console.log('ğŸ” Attempting database connection...')

    // Try to get scan from database first
    let scan = null
    let databaseError = false

    try {
      console.log('ğŸ“¡ Connecting to Prisma client...')
      console.log('ğŸ” Executing database query for scanId:', scanId)

      const startTime = Date.now()
      scan = await db.securityScan.findUnique({
        where: { id: scanId },
        include: {
          sslCheck: true,
          headersCheck: true,
          dnsCheck: true,
          performance: true,
          vulnerabilities: true,
          portScans: true,
        },
      })
      const queryTime = Date.now() - startTime

      console.log('âœ… Database query completed in', queryTime, 'ms')
      console.log('ğŸ“Š Scan found:', !!scan)

      if (scan) {
        console.log('ğŸ“‹ Scan details:', {
          id: scan.id,
          url: scan.url,
          domain: scan.domain,
          status: scan.status,
          overallScore: scan.overallScore,
          riskLevel: scan.riskLevel,
          vulnerabilitiesCount: scan.vulnerabilities?.length || 0,
          sslCheck: !!scan.sslCheck,
          headersCheck: !!scan.headersCheck,
          dnsCheck: !!scan.dnsCheck,
          performance: !!scan.performance,
          portScansCount: scan.portScans?.length || 0,
        })
      }

    } catch (dbError) {
      console.error('âŒ Database retrieval failed:', dbError)
      console.error('ğŸ” Database error details:', {
        name: dbError.name,
        message: dbError.message,
        code: dbError.code,
        meta: dbError.meta,
      })
      databaseError = true
    }

    if (!scan) {
      if (databaseError) {
        console.log('âš ï¸ Database unavailable, returning 503')
        return NextResponse.json(
          {
            error: 'Export unavailable',
            details: 'Database not configured. Export can only be performed when database is available.'
          },
          { status: 503 }
        )
      }
      console.log('âŒ Scan not found in database')
      return NextResponse.json(
        { error: 'Scan not found' },
        { status: 404 }
      )
    }

    console.log('ğŸ“ Preparing export data...')
    const data = {
      scan: {
        id: scan.id,
        url: scan.url,
        domain: scan.domain,
        status: scan.status,
        overallScore: scan.overallScore,
        riskLevel: scan.riskLevel,
        startedAt: scan.startedAt,
        completedAt: scan.completedAt,
      },
      sslCheck: scan.sslCheck ? {
        ...scan.sslCheck,
        issues: scan.sslCheck.issues ? JSON.parse(scan.sslCheck.issues) : [],
      } : null,
      headersCheck: scan.headersCheck ? {
        ...scan.headersCheck,
        missingHeaders: scan.headersCheck.missingHeaders ? JSON.parse(scan.headersCheck.missingHeaders) : [],
        issues: scan.headersCheck.issues ? JSON.parse(scan.headersCheck.issues) : [],
      } : null,
      dnsCheck: scan.dnsCheck ? {
        ...scan.dnsCheck,
        dnsRecords: scan.dnsCheck.dnsRecords ? JSON.parse(scan.dnsCheck.dnsRecords) : [],
        issues: scan.dnsCheck.issues ? JSON.parse(scan.dnsCheck.issues) : [],
      } : null,
      performance: scan.performance ? {
        ...scan.performance,
        recommendations: scan.performance.recommendations ? JSON.parse(scan.performance.recommendations) : [],
      } : null,
      vulnerabilities: scan.vulnerabilities.map((vuln) => ({
        ...vuln,
        evidence: vuln.evidence ? JSON.parse(vuln.evidence) : undefined,
      })),
      portScans: scan.portScans,
    }

    if (format === 'csv') {
      console.log('ğŸ“Š Generating CSV export...')
      const csv = generateCSV(data.vulnerabilities)
      const filename = `vulnerabilities-${scan.domain}-${new Date().toISOString().split('T')[0]}.csv`

      console.log('âœ… CSV generated successfully')
      console.log('ğŸ“„ CSV filename:', filename)
      console.log('ğŸ“ CSV length:', csv.length, 'characters')

      return new NextResponse(csv, {
        headers: {
          'Content-Type': 'text/csv; charset=utf-8',
          'Content-Disposition': `attachment; filename="${filename}"`,
        },
      })
    }

    // Default to JSON
    console.log('ğŸ“‹ Generating JSON export...')
    const filename = `security-scan-${scan.domain}-${new Date().toISOString().split('T')[0]}.json`

    console.log('âœ… JSON prepared successfully')
    console.log('ğŸ“„ JSON filename:', filename)
    console.log('ğŸ“ JSON data size:', JSON.stringify(data).length, 'characters')

    return new NextResponse(JSON.stringify(data, null, 2), {
      headers: {
        'Content-Type': 'application/json; charset=utf-8',
        'Content-Disposition': `attachment; filename="${filename}"`,
      },
    })
  } catch (error) {
    console.error('ğŸ’¥ Export error:', error)
    console.error('ğŸ” Error stack:', error.stack)
    console.error('ğŸ” Error details:', {
      name: error.name,
      message: error.message,
      code: error.code,
    })

    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    return NextResponse.json(
      { error: 'Failed to export data', details: errorMessage },
      { status: 500 }
    )
  }
}
// VULNERABILITY PROMPTS - Detailed role-specific instructions for each vulnerability type
const VULNERABILITY_PROMPTS: Record<string, string> = {
  XSS: `
#### Role-Specific Instructions for XSS Vulnerabilities

**Act as:** Senior Frontend Engineer + Security Specialist

**Objective:** Eliminate all inline JavaScript vulnerabilities and implement secure event handling patterns in React/Next.js application.

**Step-by-Step Instructions:**

1. **Audit Codebase:**
   - Scan all .tsx, .jsx, .ts, .js files for inline event handlers
   - Look for: \`onClick\`, \`onmouseover\`, \`onload\`, \`onerror\`, \`onsubmit\`, \`onchange\`, etc.
   - Look for: \`href="javascript:void(0)"\` or \`href="javascript:"\`
   - Search for: \`eval()\`, \`innerHTML\`, \`outerHTML\`, \`document.write()\`

2. **Fix Inline Event Handlers:**
   For each inline handler found:
   - Add unique \`id\` or \`data-*\` attribute to HTML element if missing
   - Create event listener in associated component file
   - Example:

   \`before:\`
   \`\`\`tsx
   <button onClick={handleDelete}>Delete</button>
   \`\`\`

   \`after:\`
   \`\`\`tsx
   const [handleDelete] = () => {
     // Delete logic
   }

   return (
     <button onClick={handleDelete} id="delete-btn">Delete</button>
   )
   \`\`\`

3. **Fix JavaScript Protocol in Href:**
   - Replace \`href="javascript:void(0)"\` with \`href="#"\` and \`event.preventDefault()\`
   - Better: Use \`<button>\` element styled as link if purely functional
   - Example:

   \`before:\`
   \`\`\`tsx
   <a href="javascript:void(0)" onclick="alert('hi')">Click</a>
   \`\`\`

   \`after:\`
   \`\`\`tsx
   <Button variant="ghost" asChild>
     <a href="#" onClick={(e) => { e.preventDefault(); alert('hi'); }}>
       Click
     </a>
   </Button>
   \`\`\`

4. **Remove Dangerous Functions:**
   - Replace \`eval()\` with \`JSON.parse()\` or \`new Function()\` (if absolutely necessary)
   - Replace \`innerHTML\` with \`textContent\` for static content
   - Replace \`innerHTML\` with \`DOMPurify.sanitize()\` for dynamic content
   - Example:

   \`before:\`
   \`\`\`tsx
   const userInput = '<script>alert("xss")</script>';
   <div>{userInput}</div>
   \`\`\`

   \`after:\`
   \`\`\`tsx
   import DOMPurify from 'dompurify';

   const userInput = '<script>alert("xss")</script>';
   <div>{DOMPurify.sanitize(userInput)}</div>
   // or for static content:
   <div>{userInput}</div>
   \`\`\`

5. **Implement Content Security Policy (CSP):**
   - Add CSP header in \`next.config.js\`
   - Use strict policy: \`default-src 'self'; script-src 'self' 'unsafe-inline'\` (temporary)
   - Goal: Eliminate need for unsafe-inline

   \`next.config.js\`:
   \`\`\`javascript
   const securityHeaders = [
     {
       key: 'Content-Security-Policy',
       value: "default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline'; object-src 'none';"
     }
   ]

   module.exports = {
     async headers() {
       return [
         {
           source: '/:path*',
           headers: securityHeaders
         }
       ]
     }
   }
   \`\`\`

**Quality Requirements:**

✅ **Security Requirements:**
- NO \`eval()\` or dangerous functions
- NO \`innerHTML\` with user data
- NO inline event handlers (use \`addEventListener\` or React \`onClick\` props)
- NO \`javascript:\` protocol in href (use \`#\` with \`preventDefault()\` or \`<button>\`)
- Implement Content Security Policy (CSP)
- Validate and sanitize ALL inputs (frontend and backend)
- Use parameterized queries (never string concatenation for SQL)

✅ **Code Quality Requirements:**
- Follow DRY principle (Don't Repeat Yourself)
- Extract reusable logic into custom hooks
- Use functional components with hooks (useState, useCallback, useRef, useEffect)
- Use proper TypeScript types (no \`any\` types)
- Handle all edge cases and error states
- Add loading states and error boundaries
- Follow consistent code formatting (use ESLint + Prettier)

✅ **Next.js 15 Specific Requirements:**
- Use App Router (not Pages Router)
- Use Server Actions for form submissions (if applicable)
- Use React 19+ features (transitions, suspense if needed)
- Optimize images (next/image)
- Use modern CSS (Tailwind CSS or CSS Modules)
- Proper metadata (app/layout.tsx)

✅ **Best Practices:**
- Comment code for future maintainability
- Write unit tests with Jest/Vitest
- Write integration tests with Playwright
- Use proper error handling (try-catch with typed errors)
- Consider performance optimizations (React.memo, useCallback, useMemo)
- Follow accessibility standards (WCAG 2.1 AA)

**Example Component:**

\`\`\`tsx
'use client'

import { useState, useCallback } from 'react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import DOMPurify from 'dompurify'

interface XSSSafeFormProps {
  onSubmit: (data: FormData) => void
}

const XSSSafeForm = ({ onSubmit }: XSSSafeFormProps) => {
  const [message, setMessage] = useState('')
  const [isSubmitting, setIsSubmitting] = useState(false)

  const handleSubmit = useCallback(async (e: React.FormEvent) => {
    e.preventDefault()
    setIsSubmitting(true)

    try {
      const formData = new FormData(e.currentTarget)
      // Sanitize input before using
      const sanitizedMessage = DOMPurify.sanitize(formData.get('message') || '')

      await onSubmit({
        message: sanitizedMessage
      })

      setMessage('')
    } catch (error) {
      console.error('Form error:', error)
    } finally {
      setIsSubmitting(false)
    }
  }, [onSubmit])

  return (
    <Card>
      <CardHeader>
        <CardTitle>XSS-Safe Form</CardTitle>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} id="xss-safe-form">
          <div className="space-y-4">
            <div>
              <label htmlFor="message">Message</label>
              <Input
                id="message"
                name="message"
                value={message}
                onChange={(e) => setMessage(e.target.value)}
                placeholder="Enter message..."
                required
              />
            </div>
            <Button
              type="submit"
              disabled={isSubmitting}
              className="w-full"
            >
              {isSubmitting ? 'Submitting...' : 'Submit'}
            </Button>
          </div>
        </form>
      </CardContent>
    </Card>
  )
}

export default XSSSafeForm
\`\`\`
`,

  CSRF: `
#### Role-Specific Instructions for CSRF Vulnerabilities

**Act as:** Senior Backend Engineer + Security Specialist

**Objective:** Implement comprehensive CSRF protection for all state-changing operations.

**Step-by-Step Instructions:**

1. **Generate Anti-CSRF Tokens:**
   - Create token generation utility in your backend
   - Use cryptographically secure random generator
   - Store tokens in user session
   - Example:

   \`lib/csrf.ts\`:
   \`\`\`typescript
   import crypto from 'crypto'

   export function generateCSRFToken(): string {
     return crypto.randomBytes(32).toString('hex')
   }

   export async function verifyCSRFToken(token: string, sessionToken: string): Promise<boolean> {
     return token === sessionToken
   }
   \`\`\`

2. **Add Token to Session:**
   - Store CSRF token in user session upon login/initialization
   - Example middleware:

   \`middleware/session.ts\`:
   \`\`\`typescript
   export async function sessionMiddleware(req, res, next) {
     // Generate and store CSRF token if not exists
     if (!req.session.csrfToken) {
       req.session.csrfToken = generateCSRFToken()
     }

     // Expose token to frontend via cookie (HttpOnly, SameSite)
     res.cookie('XSRF-TOKEN', req.session.csrfToken, {
       httpOnly: true,
       sameSite: 'strict',
       secure: process.env.NODE_ENV === 'production'
     })

     next()
   }
   \`\`\`

3. **Add Token to All Forms:**
   - Include CSRF token in all state-changing forms (POST, PUT, DELETE, PATCH)
   - Use hidden input field
   - Example:

   \`before:\`
   \`\`\`tsx
   <form method="POST" action="/api/update-profile">
     <input type="text" name="username" />
     <input type="password" name="password" />
     <button type="submit">Update</button>
   </form>
   \`\`\`

   \`after:\`
   \`\`\`tsx
   <form method="POST" action="/api/update-profile">
     <input type="hidden" name="csrf_token" value="{{ csrfToken }}" />
     <input type="text" name="username" />
     <input type="password" name="password" />
     <button type="submit">Update</button>
   </form>
   \`\`\`

   - With React:

   \`components/CSRFProtectedForm.tsx\`:
   \`\`\`tsx
   'use client'

import { useForm } from 'react-hook-form'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'

interface CSRFFormProps {
  action: string
  csrfToken: string
}

const CSRFProtectedForm = ({ action, csrfToken }: CSRFFormProps) => {
  const { register, handleSubmit } = useForm()

  const onSubmit = async (data: any) => {
    const response = await fetch(action, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken
      },
      body: JSON.stringify({
        ...data,
        csrf_token: csrfToken
      })
    })

    if (!response.ok) {
      throw new Error('Invalid CSRF token')
    }
  }

  return (
    <form onSubmit={handleSubmit} action={action} method="POST">
      <input type="hidden" {...register('csrf_token')} defaultValue={csrfToken} />
      {/* Other form fields */}
      <Button type="submit">Submit</Button>
    </form>
  )
}
   \`\`\`

4. **Add SameSite Cookie Attributes:**
   - Configure cookies with \`sameSite: 'strict'\` or \`sameSite: 'lax'\`
   - Use \`httpOnly: true\` for authentication cookies
   - Use \`secure: true\` in production
   - Example:

   \`lib/auth.ts\`:
   \`\`\`typescript
   import { cookies } from 'next/headers'

   export async function setAuthCookie(token: string) {
     const cookieStore = await cookies()

     cookieStore.set('auth-token', token, {
       httpOnly: true,
       sameSite: 'strict',
       secure: process.env.NODE_ENV === 'production',
       maxAge: 60 * 60 * 24 * 7, // 1 week
       path: '/',
     })
   }
   \`\`\`

5. **Verify Origin and Referer Headers:**
   - Validate \`Origin\` and \`Referer\` headers on API endpoints
   - Check against whitelist of allowed origins
   - Reject suspicious requests
   - Example:

   \`app/api/protected-action/route.ts\`:
   \`\`\`typescript
   import { NextRequest, NextResponse } from 'next/server'

   const ALLOWED_ORIGINS = [
     'https://example.com',
     'https://app.example.com'
   ]

   export async function POST(req: NextRequest) {
     const origin = req.headers.get('origin')
     const referer = req.headers.get('referer')

     // Validate Origin
     if (!origin || !ALLOWED_ORIGINS.includes(origin)) {
       return NextResponse.json(
         { error: 'Invalid origin' },
         { status: 403 }
       )
     }

     // Verify Referer
     if (referer && !referer.startsWith('https://example.com')) {
       return NextResponse.json(
         { error: 'Invalid referer' },
         { status: 403 }
       )
     }

     // Process request...
   }
   \`\`\`

**Quality Requirements:**

✅ **Security Requirements:**
- ALL state-changing requests must have CSRF token
- Tokens must be cryptographically secure (random, unpredictable)
- Use SameSite cookie attribute (strict or lax)
- Use HttpOnly cookies for authentication
- Validate Origin and Referer headers
- Implement short token lifetime (1 hour to 24 hours)
- Rotate tokens after use (single-use tokens for sensitive operations)

✅ **Code Quality Requirements:**
- Create reusable CSRF utilities and middleware
- Implement proper error handling for token validation
- Use TypeScript types for all CSRF-related functions
- Add proper logging for CSRF violations (monitoring)
- Follow Next.js 15 App Router patterns

✅ **Testing Requirements:**
- Unit tests for token generation and verification
- Integration tests: Try CSRF attacks (submit form without token, with invalid token)
- Test across different origins
- Test cookie security (verify SameSite, HttpOnly, Secure attributes)
- Test token rotation logic

**Example API Endpoint:**

\`\`\`typescript
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from '@/lib/auth'

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession()

    if (!session?.csrfToken) {
      return NextResponse.json(
        { error: 'No CSRF token in session' },
        { status: 400 }
      )
    }

    const { csrf_token, ...data } = await req.json()

    // Verify CSRF token
    if (csrf_token !== session.csrfToken) {
      // Log security violation
      console.error('CSRF violation:', {
        ip: req.headers.get('x-forwarded-for') || req.ip,
        userAgent: req.headers.get('user-agent'),
        referer: req.headers.get('referer'),
      })

      return NextResponse.json(
        { error: 'Invalid CSRF token' },
        { status: 403 }
      )
    }

    // Process valid request...
    return NextResponse.json(
      { success: true, data: 'Action completed' }
    )

  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to process request' },
      { status: 500 }
    )
  }
}
\`\`\`
`,

  SQL_INJECTION: `
#### Role-Specific Instructions for SQL Injection Vulnerabilities

**Act as:** Senior Backend Engineer + Database Security Specialist

**Objective:** Eliminate all SQL injection vulnerabilities by using parameterized queries and ORM.

**Step-by-Step Instructions:**

1. **Audit Database Queries:**
   - Search for ALL database queries in your codebase
   - Look for string concatenation in queries
   - Look for \`query.exec()\` or \`query.get()\` with user input
   - Search for: \`\${userInput}\`, \`' + user + '\`, template literals with user data

   \`examples to find:\`:
   \`\`\`typescript
   // ❌ VULNERABLE - String concatenation
   const query = 'SELECT * FROM users WHERE email = \'' + email + '\''
   db.query(query)

   // ❌ VULNERABLE - Template literal
   const query = \`SELECT * FROM users WHERE email = '\${email}'\`
   db.query(query)

   // ❌ VULNERABLE - Template literal with multiple inputs
   const query = \`SELECT * FROM products WHERE name LIKE '\${keyword}%' AND category = '\${category}'\`
   db.query(query)
   \`\`\`

2. **Fix Using Parameterized Queries:**
   - Replace all vulnerable queries with parameterized queries
   - Use placeholders (usually \`?\` or \`$1\`, \`$2\`)
   - Pass user input as separate parameter, not part of query string

   \`before:\`:
   \`\`\`typescript
   // ❌ VULNERABLE
   const query = 'SELECT * FROM users WHERE email = \'' + email + '\''
   const result = await db.query(query, [userId])
   \`\`\`

   \`after:\`:
   \`\`\`typescript
   // ✅ SECURE - Parameterized query
   const query = 'SELECT * FROM users WHERE email = ? AND user_id = ?'
   const result = await db.query(query, [email, userId])
   \`\`\`

3. **Use ORM (Prisma/Sequelize/TypeORM):**
   - ORMs automatically handle parameterization
   - Use ORM methods instead of raw queries
   - Validate inputs before ORM queries

   \`Prisma example:\`:
   \`\`\`typescript
   import { PrismaClient } from '@prisma/client'

   const prisma = new PrismaClient()

   // ✅ SECURE - Prisma ORM (auto-parameterized)
   const user = await prisma.user.findUnique({
     where: {
       email: email
     }
   })

   // ✅ SECURE - With additional conditions
   const users = await prisma.user.findMany({
     where: {
       AND: [
         { isActive: true },
         { role: 'USER' }
       ]
     }
   })
   \`\`\`

4. **Input Validation:**
   - Validate and sanitize ALL inputs before database queries
   - Use type checking (ensure email is actually email format)
   - Use length limits, pattern matching
   - Whitelist allowed values where possible

   \`lib/validation.ts\`:
   \`\`\`typescript
   import { z } from 'zod'

   export const emailSchema = z.string()
     .email('Invalid email address')
     .maxLength(255, 'Email too long')
     .trim()

   export const userIdSchema = z.string()
     .regex(/^[0-9]+$/, 'Invalid user ID')
     .transform(Number)
     .min(1, 'User ID must be positive')

   export const searchQuerySchema = z.string()
     .min(3, 'Search query too short')
     .max(100, 'Search query too long')
     .regex(/^[a-zA-Z0-9\\s]*$/, 'Search query can only contain letters, numbers, and spaces')

   \`usage:\`:
   \`\`\`typescript
   import { emailSchema } from '@/lib/validation'

   app.post('/api/users/search', async (req, res) => {
     const result = emailSchema.safeParse(req.body.query)

     if (!result.success) {
       return res.status(400).json({ errors: result.error.errors })
     }

     // Safe to use in database query
     const users = await prisma.user.findMany({
       where: {
         email: { contains: result.data }
       }
     })

     res.json({ users })
   })
   \`\`\`

5. **Principle of Least Privilege:**
   - Create separate database users with minimal required permissions
   - Application user: Only SELECT, INSERT, UPDATE (no DROP, ALTER, etc.)
   - Read replica: Only SELECT queries
   - Audit user: Only SELECT for logging tables

\`\`\`sql
-- ✅ SECURE - Least privilege database users

-- Application user (regular operations)
CREATE USER 'app_user' WITH PASSWORD 'secure_password_here';
GRANT SELECT, INSERT, UPDATE ON database.* TO 'app_user';

-- Read replica user (read-only queries)
CREATE USER 'read_user' WITH PASSWORD 'different_secure_password';
GRANT SELECT ON database.* TO 'read_user';

-- Audit user (logging only)
CREATE USER 'audit_user' WITH PASSWORD 'another_secure_password';
GRANT SELECT ON database.audit_logs TO 'audit_user';
\`\`\`

**Quality Requirements:**

✅ **Security Requirements:**
- NO raw SQL queries with user input
- NO string concatenation or template literals in queries
- NO dynamic SQL building
- ALWAYS use parameterized queries or ORM
- Validate all inputs (type, length, format)
- Use principle of least privilege for database users
- Sanitize outputs before displaying to users

✅ **Code Quality Requirements:**
- Use TypeScript types for all database models
- Create repository/service layer for database operations
- Implement proper error handling for database errors
- Use connection pooling and proper query optimization
- Add comprehensive logging for database operations
- Use environment variables for database credentials

✅ **Next.js 15 Specific Requirements:**
- Use Prisma ORM (recommended for Next.js 15)
- Use Server Actions for database mutations (better security, no API endpoints needed)
- Implement proper error boundaries for database errors
- Use optimistic UI updates with Server Actions

✅ **Testing Requirements:**
- Unit tests for all database queries
- Integration tests with real database (test environment)
- Security tests: Try SQL injection attacks (inject \`' OR '1'='1\`, etc.)
- Performance tests for complex queries
- Load tests for database operations

**Example Server Action (Next.js 15):**

\`\`\`typescript
'use server'

import { revalidatePath } from 'next/cache'
import { prisma } from '@/lib/prisma'
import { z } from 'zod'
import { redirect } from 'next/navigation'
import { auth } from '@/lib/auth'

const updateUserSchema = z.object({
  id: z.string().min(1).transform(Number),
  email: z.string().email(),
  name: z.string().min(1).max(255),
})

export async function updateUser(formData: FormData) {
  const session = await auth()

  if (!session?.user?.id) {
    return { error: 'Unauthorized' }
  }

  const result = updateUserSchema.safeParse({
    id: formData.get('id'),
    email: formData.get('email'),
    name: formData.get('name'),
  })

  if (!result.success) {
    return { error: result.error.flatten().fieldErrors }
  }

  const { id, email, name } = result.data

  // ✅ SECURE - Prisma ORM handles parameterization automatically
  const user = await prisma.user.update({
    where: {
      id: id,
      userId: session.user.id, // Additional security check
    },
    data: {
      email,
      name,
    }
  })

  revalidatePath('/profile')
  redirect('/profile')
}
\`\`\`
`
}

export default VULNERABILITY_PROMPTS
